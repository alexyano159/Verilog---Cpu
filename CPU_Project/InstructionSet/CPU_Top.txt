Instructions Exmaples:
Store : Store R5 , [R2+8]
store the value in register R5 which is in registerfile into memory at adress (R2+8). 
opcode - store , rs1(base) - R2 , rs2(data) - R5 , immediate=8.
# STORE Instruction Execution Step-by-Step

## 1. Fetch

- **PC (Program Counter):**
  - **Code:** `Program_Counter pc_reg (...);`
  - **What it does:** Holds address of next instruction to be fetched.
  - **Uses:** `assign instruction_address = pc_current[9:2];`
- **IR (Instruction Register):**
  - **Code:** `Instruction_Register ir_reg (...);`
  - **What it does:** Loads instruction from ROM using `instruction_data` and stores it.
  - **Uses:** `assign ir_load = 1'b1;` (always loads new instruction each cycle)
- **Top Module Action:**  
  - Instruction is fetched from ROM at address from `PC` and loaded into `IR`.

---

## 2. Decode

- **IR (Instruction Register):**
  - **Code:** `Instruction_Register ir_reg (...);`
  - **What it does:** Holds decoded instruction (STORE R5, [R2 + 8]).
  - **Uses:**  
    - `assign rs1_addr = ir[21:17];` // base register for address  
    - `assign rs2_addr = ir[16:12];` // register holding data to store  
    - `assign immediate = {{20{ir[11]}}, ir[11:0]};` // sign-extended immediate
- **Register File:**
  - **Code:** `Register_File reg_file (...);`
  - **What it does:** Reads values from registers:
    - `read_reg1(rs1_addr)` → `reg_data1` (R2, base address)
    - `read_reg2(rs2_addr)` → `reg_data2` (R5, data to be stored)
- **Top Module Action:**  
  - Control Unit uses IR to decode opcode, source registers, immediate values.

---

## 3. Execute / Address Calculation

- **ALU:**
  - **Code:** `Cpu_Alu alu (...);`
  - **What it does:** Calculates effective address for RAM access.
    - `assign alu_A = reg_data1;`
    - `assign alu_B = AluSrc ? immediate : reg_data2;` (for STORE, AluSrc=1, so immediate used)
    - ALU performs ADD: `alu_result = alu_A + alu_B` (20 + 8 = 28)
- **MAR (Memory Address Register):**
  - **Code:** `Memory_Adress_Register mar_reg (...);`
  - **What it does:** Loads calculated address from ALU.
    - `address_in(address_bus)`
    - `assign address_bus = reg_data1 + immediate;`
    - `assign mar_load = MemRead || MemWrite;` (for STORE, MemWrite=1)
- **Top Module Action:**  
  - ALU calculates address; MAR loads this address for use by RAM.

---

## 4. Memory Access

- **MAR (Memory Address Register):**
  - **Code:** `Memory_Adress_Register mar_reg (...);`
  - **What it does:** Holds the address in RAM to store data (`mar = 28`).
  - **Uses:** `assign data_address = mar[7:0];` (only lower 8 bits for RAM)
- **RAM (Data Memory):**
  - **External module, but driven by:**
    - `assign write_data = reg_data2;` (data to write—value from R5)
    - `assign write_enable = MemWrite;` (enabled by control unit)
    - Data is written to RAM at `data_address` (28), with value from `write_data` (99).
- **MDR (Memory Data Register):**
  - **Not needed for STORE in this design (typically used for LOAD).**
- **Top Module Action:**  
  - reg_data2 (R5) is written to RAM at the calculated address (28) when MemWrite is enabled.

---

## 5. Write-back

- **Register File:**
  - **No action for STORE.** (No register is written; only RAM is updated)
  - Register file write enable (`RegWrite`) is 0 for STORE.

- **PC (Program Counter):**
  - **Code:**  
    - `assign pc_next = Jump ? jump_target : (Branch && branch_taken) ? branch_target : pc_current + 4;`
    - `assign pc_load = Jump || (Branch && branch_taken);`
  - **What it does:** Advances to next instruction (unless branch/jump).


LOAD:
LOAD R5, [R2 + 8] means:

Read the data from memory at the address (R2 + 8) and store it into register R5.

Step-by-Step:
R2: A register in the register file (contains a value, say 20).
8: An immediate offset.
R2 + 8: The effective memory address (e.g., 20 + 8 = 28).
Memory[28]: The value stored in RAM at address 28.
R5: The destination register to hold the loaded value.

## 1. Fetch

- **PC (Program Counter):**
  - **Code:** `Program_Counter pc_reg (...);`
  - **What it does:** Holds address of the next instruction to be fetched.
  - **Uses:** `assign instruction_address = pc_current[9:2];`
- **IR (Instruction Register):**
  - **Code:** `Instruction_Register ir_reg (...);`
  - **What it does:** Loads instruction from ROM using `instruction_data` and stores it.
  - **Uses:** `assign ir_load = 1'b1;` (always loads new instruction each cycle)
- **Top Module Action:**  
  - Instruction is fetched from ROM at the address from `PC` and loaded into `IR`.

---

## 2. Decode

- **IR (Instruction Register):**
  - **Code:** `Instruction_Register ir_reg (...);`
  - **What it does:** Holds decoded instruction (e.g., `LOAD R5, [R2 + 8]`).
  - **Uses:**  
    - `assign rs1_addr = ir[21:17];` // base register for address  
    - `assign rd_addr = ir[26:22];`  // destination register to load data  
    - `assign immediate = {{20{ir[11]}}, ir[11:0]};` // sign-extended immediate
- **Register File:**
  - **Code:** `Register_File reg_file (...);`
  - **What it does:** Reads value from base register:
    - `read_reg1(rs1_addr)` → `reg_data1` (R2, base address)
    - Destination register (rd_addr) will be written later.
- **Top Module Action:**  
  - Control Unit uses IR to decode opcode, source register, destination register, immediate.

---

## 3. Execute / Address Calculation

- **ALU:**
  - **Code:** `Cpu_Alu alu (...);`
  - **What it does:** Calculates effective address for RAM access.
    - `assign alu_A = reg_data1;`
    - `assign alu_B = AluSrc ? immediate : reg_data2;` (for LOAD, AluSrc=1, so immediate used)
    - ALU performs ADD: `alu_result = alu_A + alu_B` (e.g., 20 + 8 = 28)
- **MAR (Memory Address Register):**
  - **Code:** `Memory_Adress_Register mar_reg (...);`
  - **What it does:** Loads calculated address from ALU.
    - `address_in(address_bus)`
    - `assign address_bus = reg_data1 + immediate;`
    - `assign mar_load = MemRead || MemWrite;` (for LOAD, MemRead=1)
- **Top Module Action:**  
  - ALU calculates address; MAR loads this address for use by RAM.

---

## 4. Memory Access

- **MAR (Memory Address Register):**
  - **Code:** `Memory_Adress_Register mar_reg (...);`
  - **What it does:** Holds the address in RAM to read data (`mar = 28`).
  - **Uses:** `assign data_address = mar[7:0];` (only lower 8 bits for RAM)
- **RAM (Data Memory):**
  - **External module, but driven by:**
    - `assign read_data` (data from RAM at `data_address`)
    - `assign MemRead` (enabled by control unit)
- **MDR (Memory Data Register):**
  - **Code:** `Memory_Data_Register mdr_reg (...);`
  - **What it does:** Loads data read from RAM.
    - `data_in(read_data)`
    - `assign mdr_load = MemRead;` (for LOAD, MemRead=1)
- **Top Module Action:**  
  - Data from RAM at `data_address` is loaded into MDR.

---

## 5. Write-back

- **Register File:**
  - **Code:**  
    - `assign write_back = MemtoReg ? mdr : alu_result;` (for LOAD, MemtoReg=1, so MDR used)
    - `write_en(RegWrite)` (enabled for LOAD)
    - `write_reg(rd_addr)` (destination register, e.g., R5)
    - `write_data(write_back)` (data to write—value from MDR)
  - **What it does:** Writes the loaded value from RAM into the destination register.
- **PC (Program Counter):**
  - **Code:**  
    - `assign pc_next = Jump ? jump_target : (Branch && branch_taken) ? branch_target : pc_current + 4;`
    - `assign pc_load = Jump || (Branch && branch_taken);`
  - **What it does:** Advances to next instruction (unless branch/jump).

---